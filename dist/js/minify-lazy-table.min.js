// src/utils.js
var isLimitReached = (current, total) => current >= total;
var generateUrl = (endpoint, limit, offsetKey, page) => {
  const url = new URL(endpoint);
  if (limit) {
    url.searchParams.append("limit", limit);
    url.searchParams.append(offsetKey, page * limit);
  }
  return url;
};

// src/events.js
var createObserver = (callback) => new IntersectionObserver(callback);

// src/fetch.js
var fetchData = async (url) => {
  const response = await fetch(url);
  return await response.json();
};

// src/cell.js
var render = (data) => {
  const element = document.createElement("td");
  element.innerHTML = data;
  return element;
};

// src/row.js
var render2 = (exampleElement, keys) => (data) => {
  const element = exampleElement.cloneNode(true);
  keys.forEach((key) => {
    element.appendChild(render(data[key]));
    element.removeAttribute("style");
    element.removeAttribute("data-row");
  });
  return element;
};

// src/table.js
var render3 = (tbodyElement) => (data) => {
  const keys = Array.from(document.querySelectorAll("[data-key]")).map((key) => key.dataset.key);
  const exampleElement = document.querySelector("[data-row]");
  const rowRenderer = render2(exampleElement, keys);
  data.forEach((row2) => {
    tbodyElement.appendChild(rowRenderer(row2));
  });
};

// src/main.js
var makeTableLazy = (table2) => {
  let responseTotal = table2.dataset.responseTotal;
  const {
    limit,
    endpoint,
    offsetKey,
    responseSource
  } = table2.dataset;
  if (!endpoint) {
    throw new Error("Please add data-endpoint attribute to your table");
  }
  let page = 0;
  const loaderElement = table2.querySelector("[data-loader]");
  const tableRenderer = render3(table2.querySelector("tbody"));
  const observer = createObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        fetchData(generateUrl(endpoint, limit, offsetKey, page++)).then((response) => {
          tableRenderer(responseSource ? response[responseSource] : response);
          if (isNaN(responseTotal)) {
            responseTotal = response[responseTotal];
          }
          if (isLimitReached(Array.from(table2.querySelectorAll("tbody tr:not([data-row])")).length, responseTotal)) {
            observer.unobserve(loaderElement);
            loaderElement.style.display = "none";
          }
        });
      }
    });
  });
  observer.observe(loaderElement);
};
document.addEventListener("DOMContentLoaded", () => {
  const tables = document.querySelectorAll(".lazy-table");
  tables.forEach(makeTableLazy);
});
